<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/third-part/css/ali.font.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Mysql逻辑架构1. 逻辑架构剖析1. 1 服务器处理客户端请求那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示： 下面具体展开看一下： 1.2 Connectors1.3 第 1 层：连接层系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。 经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql逻辑架构">
<meta property="og:url" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="技术日记簿">
<meta property="og:description" content="Mysql逻辑架构1. 逻辑架构剖析1. 1 服务器处理客户端请求那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示： 下面具体展开看一下： 1.2 Connectors1.3 第 1 层：连接层系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。 经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/1.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/2.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/3.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/4.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/5.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/6.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/7.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/8.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/9.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/10.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/11.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/12.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/13.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/14.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/15.png">
<meta property="og:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/16.png">
<meta property="article:published_time" content="2018-12-08T11:44:52.000Z">
<meta property="article:modified_time" content="2023-06-14T12:13:03.502Z">
<meta property="article:author" content="wenchao">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/1.png">

<link rel="canonical" href="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Mysql逻辑架构 | 技术日记簿</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="技术日记簿" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">技术日记簿</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wangwenchao1991" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="wenchao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术日记簿">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mysql逻辑架构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-08 19:44:52" itemprop="dateCreated datePublished" datetime="2018-12-08T19:44:52+08:00">2018-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-14 20:13:03" itemprop="dateModified" datetime="2023-06-14T20:13:03+08:00">2023-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Mysql逻辑架构"><a href="#Mysql逻辑架构" class="headerlink" title="Mysql逻辑架构"></a>Mysql逻辑架构</h1><h2 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a>1. 逻辑架构剖析</h2><h2 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1. 1 服务器处理客户端请求"></a>1. 1 服务器处理客户端请求</h2><h5 id="那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示："><a href="#那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：" class="headerlink" title="那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示："></a>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</h5><p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/1.png"></p>
<h5 id="下面具体展开看一下："><a href="#下面具体展开看一下：" class="headerlink" title="下面具体展开看一下："></a>下面具体展开看一下：</h5><p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/2.png"></p>
<h3 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h3><h3 id="1-3-第-1-层：连接层"><a href="#1-3-第-1-层：连接层" class="headerlink" title="1.3 第 1 层：连接层"></a>1.3 第 1 层：连接层</h3><p>系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。</p>
<p>经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</span><br><span class="line">用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依</span><br><span class="line">赖于此时读到的权限</span><br></pre></td></tr></table></figure>

<p>TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后<br>面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h3 id="1-4-第-2-层：服务层"><a href="#1-4-第-2-层：服务层" class="headerlink" title="1.4 第 2 层：服务层"></a>1.4 第 2 层：服务层</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQL Interface: SQL接口</span><br><span class="line">接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ... FROM就是调用SQL</span><br><span class="line">Interface</span><br><span class="line">MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定</span><br><span class="line">义函数等多种SQL语言接口</span><br><span class="line">Parser: 解析器</span><br><span class="line">在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构</span><br><span class="line">传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错</span><br><span class="line">误，那么就说明这个SQL语句是不合理的。</span><br><span class="line">在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字</span><br><span class="line">典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还</span><br><span class="line">会对SQl查询进行语法上的优化，进行查询重写。</span><br><span class="line">Optimizer: 查询优化器</span><br></pre></td></tr></table></figure>

<h5 id="SQL语句在语法解析之后、查询之前会使用查询优化器确定-SQL-语句的执行路径，生成一个"><a href="#SQL语句在语法解析之后、查询之前会使用查询优化器确定-SQL-语句的执行路径，生成一个" class="headerlink" title="SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个"></a>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个</h5><h5 id="执行计划。"><a href="#执行计划。" class="headerlink" title="执行计划。"></a>执行计划。</h5><h5 id="这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连"><a href="#这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连" class="headerlink" title="这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连"></a>这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连</h5><h5 id="接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将"><a href="#接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将" class="headerlink" title="接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将"></a>接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将</h5><h5 id="查询结果返回给用户。"><a href="#查询结果返回给用户。" class="headerlink" title="查询结果返回给用户。"></a>查询结果返回给用户。</h5><h5 id="它使用“选取-投影-连接”策略进行查询。例如："><a href="#它使用“选取-投影-连接”策略进行查询。例如：" class="headerlink" title="它使用“选取-投影-连接”策略进行查询。例如："></a>它使用“选取-投影-连接”策略进行查询。例如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过</span><br><span class="line">滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过</span><br><span class="line">滤，将这两个查询条件连接起来生成最终查询结果。</span><br><span class="line">Caches &amp; Buffers： 查询缓存组件</span><br><span class="line">MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结</span><br><span class="line">果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过</span><br><span class="line">程了，直接将结果反馈给客户端。</span><br><span class="line">这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</span><br><span class="line">这个查询缓存可以在不同客户端之间共享。</span><br><span class="line">从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</span><br></pre></td></tr></table></figure>

<h3 id="1-5-第-3-层：引擎层"><a href="#1-5-第-3-层：引擎层" class="headerlink" title="1. 5 第 3 层：引擎层"></a>1. 5 第 3 层：引擎层</h3><p>插件式存储引擎层（ Storage Engines）， <strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别<br>维护的底层数据执行操作</strong> ，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样<br>我们可以根据自己的实际需要进行选取。</p>
<p>MySQL 8.0.25默认支持的存储引擎如下：</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/3.png"></p>
<h3 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1. 6 存储层"></a>1. 6 存储层</h3><h5 id="所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存"><a href="#所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存" class="headerlink" title="所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存"></a>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存</h5><p>在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设<br>备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用<br>DAS、NAS、SAN等各种存储系统。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小故事：</span><br><span class="line">如果我问你9+8×16-3×2×17的值是多少，你可能会用计算器去算一下，最终结果 35 。如果再问你一遍9+8×16-</span><br><span class="line">3×2×17的值是多少，你还用再傻呵呵的再算一遍吗？我们刚刚已经算过了，直接说答案就好了。</span><br></pre></td></tr></table></figure>

<h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1. 7 小结"></a>1. 7 小结</h3><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/4.png"></p>
<h5 id="简化为三层结构："><a href="#简化为三层结构：" class="headerlink" title="简化为三层结构："></a>简化为三层结构：</h5><h5 id="1-连接层：客户端和服务器端建立连接，客户端发送-SQL-至服务器端；"><a href="#1-连接层：客户端和服务器端建立连接，客户端发送-SQL-至服务器端；" class="headerlink" title="1. 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；"></a>1. 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</h5><h5 id="2-SQL-层（服务层）：对-SQL-语句进行查询处理；与数据库文件的存储方式无关；"><a href="#2-SQL-层（服务层）：对-SQL-语句进行查询处理；与数据库文件的存储方式无关；" class="headerlink" title="2. SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；"></a>2. SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</h5><h5 id="3-存储引擎层：与数据库文件打交道，负责数据的存储和读取。"><a href="#3-存储引擎层：与数据库文件打交道，负责数据的存储和读取。" class="headerlink" title="3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。"></a>3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。</h5><h2 id="2-SQL执行流程"><a href="#2-SQL执行流程" class="headerlink" title="2. SQL执行流程"></a>2. SQL执行流程</h2><h3 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2. 1 MySQL 中的 SQL执行流程"></a>2. 1 MySQL 中的 SQL执行流程</h3><p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/5.png"></p>
<p><strong>MySQL的查询流程：</strong></p>
<p><strong>1. 查询缓存</strong> ：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没<br>有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃<br>了这个功能。</p>
<p><strong>大多数情况查询缓存就是个鸡肋，为什么呢？</strong></p>
<h5 id="查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在"><a href="#查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在" class="headerlink" title="查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在"></a>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在</h5><p>MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降<br>低，只有相同的查询操作才会命中查询缓存。两个查询请求在任何字符上的不同（例如：空格、注释、<br>大小写），都会导致缓存不会命中。因此 MySQL 的查询缓存命中率不高。</p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、<br>information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数<br>举例，可能同样的函数的两次调用会产生不一样的结果，比如函数NOW，每次调用都会产生最新的当前<br>时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次<br>查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询<br>的结果就是错误的！</p>
<p>此外，既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的<br>结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER<br>TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高<br>速缓存中删除！对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p><strong>2. 解析器</strong> ：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/6.png"></p>
<p>分析器先做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面<br>的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语<br>句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name FROM employees WHERE employee_id = 101;</span><br></pre></td></tr></table></figure>

<p>接着，要做“语法分析”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输<br>入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p>select department_id,job_id,avg(salary) from employees group by department_id;</p>
<p>如果SQL语句正确，则会生成一个这样的语法树：</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/7.png"></p>
<h5 id="3-优化器-：在优化器中会确定-SQL-语句的执行路径，比如是根据全表检索，还是根据索引检索等。"><a href="#3-优化器-：在优化器中会确定-SQL-语句的执行路径，比如是根据全表检索，还是根据索引检索等。" class="headerlink" title="3. 优化器 ：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引检索等。"></a>3. 优化器 ：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引检索等。</h5><p>举例：如下语句是执行两个表的 join：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test1 join test2 using(ID)</span><br><span class="line">where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方案 1 ：可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判</span><br><span class="line">断 test2 里面 name的值是否等于 &#x27;mysql高级课程&#x27;。</span><br><span class="line">方案 2 ：可以先从表 test2 里面取出 name=&#x27;mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1，</span><br><span class="line">再判断 test1 里面 name的值是否等于 zhangwei。</span><br><span class="line"></span><br><span class="line">这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化</span><br><span class="line">器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。。</span><br></pre></td></tr></table></figure>

<h5 id="在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。"><a href="#在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。" class="headerlink" title="在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。"></a>在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</h5><h5 id="4-执行器-："><a href="#4-执行器-：" class="headerlink" title="4. 执行器 ："></a>4. 执行器 ：</h5><h5 id="截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。"><a href="#截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。" class="headerlink" title="截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。"></a>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。</h5><p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/8.png"></p>
<h5 id="在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行-SQL查询并返回结果。在-MySQL8-0-以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。"><a href="#在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行-SQL查询并返回结果。在-MySQL8-0-以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。" class="headerlink" title="在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。"></a>在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id= 1 ;</span><br></pre></td></tr></table></figure>



<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 1 ，如果不是则跳过，如果是则将这行存在结果集中；</span><br><span class="line">调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</span><br><span class="line"></span><br><span class="line">执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</span><br></pre></td></tr></table></figure>



<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p>
<p>SQL 语句在 MySQL 中的流程是：SQL语句→查询缓存→解析器→优化器→执行器。</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/9.png"></p>
<h3 id="2-2-MySQL-8-中SQL执行原理"><a href="#2-2-MySQL-8-中SQL执行原理" class="headerlink" title="2. 2 MySQL 8 中SQL执行原理"></a>2. 2 MySQL 8 中SQL执行原理</h3><h4 id="1-确认profiling-是否开启"><a href="#1-确认profiling-是否开启" class="headerlink" title="1. 确认profiling 是否开启"></a>1. 确认profiling 是否开启</h4><p>profiling&#x3D;0 代表关闭，我们需要把 profiling 打开，即设置为 1 ：</p>
<h4 id="2-多次执行相同SQL查询"><a href="#2-多次执行相同SQL查询" class="headerlink" title="2. 多次执行相同SQL查询"></a>2. 多次执行相同SQL查询</h4><h5 id="然后我们执行一个-SQL-查询（你可以执行任何一个-SQL-查询）："><a href="#然后我们执行一个-SQL-查询（你可以执行任何一个-SQL-查询）：" class="headerlink" title="然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）："></a>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</h5><h4 id="3-查看profiles"><a href="#3-查看profiles" class="headerlink" title="3. 查看profiles"></a>3. 查看profiles</h4><p>查看当前会话所产生的所有 profiles：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling= 1 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;  # 显示最近的几次查询</span><br></pre></td></tr></table></figure>

<h4 id="4-查看profile"><a href="#4-查看profile" class="headerlink" title="4. 查看profile"></a>4. 查看profile</h4><h5 id="显示执行计划，查看程序的执行步骤："><a href="#显示执行计划，查看程序的执行步骤：" class="headerlink" title="显示执行计划，查看程序的执行步骤："></a>显示执行计划，查看程序的执行步骤：</h5><p>当然你也可以查询指定的 Query ID，比如：</p>
<h5 id="查询-SQL-的执行时间结果和上面是一样的。"><a href="#查询-SQL-的执行时间结果和上面是一样的。" class="headerlink" title="查询 SQL 的执行时间结果和上面是一样的。"></a>查询 SQL 的执行时间结果和上面是一样的。</h5><h5 id="此外，还可以查询更丰富的内容："><a href="#此外，还可以查询更丰富的内容：" class="headerlink" title="此外，还可以查询更丰富的内容："></a>此外，还可以查询更丰富的内容：</h5><h5 id="继续："><a href="#继续：" class="headerlink" title="继续："></a>继续：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 7 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 6 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 7 ;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-MySQL-5-7-中SQL执行原理"><a href="#2-3-MySQL-5-7-中SQL执行原理" class="headerlink" title="2. 3 MySQL 5. 7 中SQL执行原理"></a>2. 3 MySQL 5. 7 中SQL执行原理</h3><p>上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用<br>缓存吗？这里我们需要显式开启查询缓存模式。在MySQL5.7中如下设置：</p>
<h4 id="1-配置文件中开启查询缓存"><a href="#1-配置文件中开启查询缓存" class="headerlink" title="1. 配置文件中开启查询缓存"></a>1. 配置文件中开启查询缓存</h4><p>在 &#x2F;etc&#x2F;my.cnf 中新增一行：</p>
<h4 id="2-重启mysql服务"><a href="#2-重启mysql服务" class="headerlink" title="2. 重启mysql服务"></a>2. 重启mysql服务</h4><h4 id="3-开启查询执行计划"><a href="#3-开启查询执行计划" class="headerlink" title="3. 开启查询执行计划"></a>3. 开启查询执行计划</h4><p>由于重启过服务，需要重新执行如下指令，开启profiling。</p>
<h4 id="4-执行语句两次："><a href="#4-执行语句两次：" class="headerlink" title="4. 执行语句两次："></a>4. 执行语句两次：</h4><h4 id="5-查看profiles"><a href="#5-查看profiles" class="headerlink" title="5. 查看profiles"></a>5. 查看profiles</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type= 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling= 1 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from locations;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from locations;</span><br></pre></td></tr></table></figure>

<h4 id="6-查看profile"><a href="#6-查看profile" class="headerlink" title="6. 查看profile"></a>6. 查看profile</h4><h5 id="显示执行计划，查看程序的执行步骤：-1"><a href="#显示执行计划，查看程序的执行步骤：-1" class="headerlink" title="显示执行计划，查看程序的执行步骤："></a>显示执行计划，查看程序的执行步骤：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 1 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 2 ;</span><br></pre></td></tr></table></figure>

<h5 id="结论不言而喻。执行编号-2-时，比执行编号-1-时少了很多信息，从截图中可以看出查询语句直接从缓存中"><a href="#结论不言而喻。执行编号-2-时，比执行编号-1-时少了很多信息，从截图中可以看出查询语句直接从缓存中" class="headerlink" title="结论不言而喻。执行编号 2 时，比执行编号 1 时少了很多信息，从截图中可以看出查询语句直接从缓存中"></a>结论不言而喻。执行编号 2 时，比执行编号 1 时少了很多信息，从截图中可以看出查询语句直接从缓存中</h5><h5 id="获取数据。"><a href="#获取数据。" class="headerlink" title="获取数据。"></a>获取数据。</h5><h3 id="2-4-SQL语法顺序"><a href="#2-4-SQL语法顺序" class="headerlink" title="2.4 SQL语法顺序"></a>2.4 SQL语法顺序</h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同<br>而动态调整执行顺序。</p>
<p>需求：查询每个部门年龄高于 20 岁的人数且高于 20 岁人数不能少于 2 人，显示人数最多的第一名部门信息</p>
<p>下面是经常出现的查询顺序：</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/10.png"></p>
<h3 id="2-5-Oracle中的SQL执行流程-了解"><a href="#2-5-Oracle中的SQL执行流程-了解" class="headerlink" title="2.5 Oracle中的SQL执行流程(了解)"></a>2.5 Oracle中的SQL执行流程(了解)</h3><p>Oracle 中采用了共享池来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用<br>硬解析还是软解析。</p>
<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/11.png"></p>
<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。</p>
<p><strong>1 .语法检查：</strong> 检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</p>
<p><strong>2 .语义检查：</strong> 检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统<br>就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</p>
<p><strong>3 .权限检查：</strong> 看用户是否具备访问该数据的权限。</p>
<p><strong>4.共享池检查：</strong> 共享池（Shared Pool）是一块内存池， <strong>最主要的作用是缓存 SQL 语句和该语句的执行计<br>划。</strong> Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析<br>和硬解析又该怎么理解呢？</p>
<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中<br>查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。</p>
<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”<br>这个步骤，这就是硬解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</span><br><span class="line">6. 执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执</span><br><span class="line">行语句了。</span><br></pre></td></tr></table></figure>

<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要<br>缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对<br>象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>
<p>库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量<br>避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p>
<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中，绑定变量是它的一大特色。绑定变量<br>就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解<br>析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况<br>而定。</p>
<p>举个例子，我们可以使用下面的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from player where player_id = 10001 ;</span><br></pre></td></tr></table></figure>

<p>你也可以使用绑定变量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from player where player_id = :player_id;</span><br></pre></td></tr></table></figure>

<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id &#x3D; 10001 之后，还会查询10002 、 10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。 </p>
<p>因此， <strong>我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。</strong> 但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。</p>
<p><strong>Oracle的架构图：</strong></p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/12.png"></p>
<h5 id="简图："><a href="#简图：" class="headerlink" title="简图："></a>简图：</h5><p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/13.png"></p>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享<br>池来判断是进行软解析，还是硬解析。</p>
<h2 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池(buffer pool)"></a>3. 数据库缓冲池(buffer pool)</h2><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页<br>面（包括读页面、写页面、创建新页面等操作）。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操<br>作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为<br>数据缓冲池，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访<br>问。</p>
<p>这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I&#x2F;O 的时间。要知道，这种策略对提<br>升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h3 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a>3.1 缓冲池 vs 查询缓存</h3><h5 id="缓冲池和查询缓存是一个东西吗？不是。"><a href="#缓冲池和查询缓存是一个东西吗？不是。" class="headerlink" title="缓冲池和查询缓存是一个东西吗？不是。"></a>缓冲池和查询缓存是一个东西吗？不是。</h5><h4 id="1-缓冲池（Buffer-Pool）"><a href="#1-缓冲池（Buffer-Pool）" class="headerlink" title="1. 缓冲池（Buffer Pool）"></a>1. 缓冲池（Buffer Pool）</h4><p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。</p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/14.png"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p>
<p><strong>缓存池的重要性：</strong></p>
<p><strong>缓存原则：</strong></p>
<p>“位置 * 频次”这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p>
<p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>
<p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200 G，但是内存只有 16 G，缓冲<br>池大小只有 1 G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。</p>
<p><strong>缓冲池的预读特性：</strong></p>
<h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h4><h5 id="那么什么是查询缓存呢？"><a href="#那么什么是查询缓存呢？" class="headerlink" title="那么什么是查询缓存呢？"></a>那么什么是查询缓存呢？</h5><h5 id="查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在-1"><a href="#查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在-1" class="headerlink" title="查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在"></a>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在</h5><p>MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表<br>发生变化，查询缓存就会失效，因此命中率低。</p>
<h3 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3. 2 缓冲池如何读取数据"></a>3. 2 缓冲池如何读取数据</h3><h5 id="缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。"><a href="#缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。" class="headerlink" title="缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。"></a>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</h5><h5 id="缓存在数据库中的结构和作用如下图所示："><a href="#缓存在数据库中的结构和作用如下图所示：" class="headerlink" title="缓存在数据库中的结构和作用如下图所示："></a>缓存在数据库中的结构和作用如下图所示：</h5><p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/15.png"></p>
<h5 id="如果我们执行-SQL-语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？"><a href="#如果我们执行-SQL-语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？" class="headerlink" title="如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？"></a>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</h5><h3 id="3-3-查看-x2F-设置缓冲池的大小"><a href="#3-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="3. 3 查看&#x2F;设置缓冲池的大小"></a>3. 3 查看&#x2F;设置缓冲池的大小</h3><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大<br>小。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure>

<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728 &#x2F; 1024 &#x2F; 1024 &#x3D; 128 MB。我们可以修改缓冲池大小，比如改为 256 MB，方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size = 268435456 ;</span><br></pre></td></tr></table></figure>

<h5 id="或者："><a href="#或者：" class="headerlink" title="或者："></a>或者：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure>

<h5 id="然后再来看下修改后的缓冲池大小，此时已成功修改成了-256-MB："><a href="#然后再来看下修改后的缓冲池大小，此时已成功修改成了-256-MB：" class="headerlink" title="然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB："></a>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB：</h5><h3 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a>3.4 多个Buffer Pool实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure>

<p>这样就表明我们要创建 2 个Buffer Pool实例。</p>
<p>我们看下如何查看缓冲池的个数，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>

<p>那每个Buffer Pool实例实际占多少内存空间呢？其实使用这个公式算出来的：</p>
<p>也就是总共的大小除以实例的个数，结果就是每个Buffer Pool实例占用的大小。</p>
<h3 id="3-5-引申问题"><a href="#3-5-引申问题" class="headerlink" title="3.5 引申问题"></a>3.5 引申问题</h3><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>
<p><strong>黑盒下的更新数据流程</strong>nnodb_buffer_pool_instances’;</p>
<p><img src="/2018/12/08/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/16.png"></p>
<h5 id="我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回"><a href="#我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回" class="headerlink" title="我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回"></a>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回</h5><h5 id="滚都做不到还谈什么崩溃恢复？"><a href="#滚都做不到还谈什么崩溃恢复？" class="headerlink" title="滚都做不到还谈什么崩溃恢复？"></a>滚都做不到还谈什么崩溃恢复？</h5><p>答案： <strong>Redo Log &amp; Undo Log</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Mysql/" rel="tag"># Mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" rel="prev" title="MySQL用户与权限管理">
      <i class="fa fa-chevron-left"></i> MySQL用户与权限管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="next" title="Mysql存储引擎">
      Mysql存储引擎 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">Mysql逻辑架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90"><span class="nav-number">1.1.</span> <span class="nav-text">1. 逻辑架构剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.</span> <span class="nav-text">1. 1 服务器处理客户端请求</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%82%A3%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%8C%E6%89%8D%E8%83%BD%E4%BA%A7%E7%94%9F%E6%9C%80%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%E5%91%A2%EF%BC%9F%E8%BF%99%E9%87%8C%E4%BB%A5%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%EF%BC%9A"><span class="nav-number">1.2.0.0.1.</span> <span class="nav-text">那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E9%9D%A2%E5%85%B7%E4%BD%93%E5%B1%95%E5%BC%80%E7%9C%8B%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="nav-number">1.2.0.0.2.</span> <span class="nav-text">下面具体展开看一下：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Connectors"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2 Connectors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%AC%AC-1-%E5%B1%82%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.3 第 1 层：连接层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%AC%AC-2-%E5%B1%82%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.4 第 2 层：服务层</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%90%8E%E3%80%81%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%89%8D%E4%BC%9A%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%A1%AE%E5%AE%9A-SQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA"><span class="nav-number">1.2.3.0.1.</span> <span class="nav-text">SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E3%80%82"><span class="nav-number">1.2.3.0.2.</span> <span class="nav-text">执行计划。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A1%A8%E6%98%8E%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%85%A8%E8%A1%A8%E6%A3%80%E7%B4%A2%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%A3%80%E7%B4%A2%EF%BC%89%EF%BC%8C%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E"><span class="nav-number">1.2.3.0.3.</span> <span class="nav-text">这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%EF%BC%8C%E6%9C%80%E5%90%8E%E4%BC%9A%E6%8C%89%E7%85%A7%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9D%A5%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%B9%B6%E5%B0%86"><span class="nav-number">1.2.3.0.4.</span> <span class="nav-text">接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%BB%99%E7%94%A8%E6%88%B7%E3%80%82"><span class="nav-number">1.2.3.0.5.</span> <span class="nav-text">查询结果返回给用户。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%83%E4%BD%BF%E7%94%A8%E2%80%9C%E9%80%89%E5%8F%96-%E6%8A%95%E5%BD%B1-%E8%BF%9E%E6%8E%A5%E2%80%9D%E7%AD%96%E7%95%A5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="nav-number">1.2.3.0.6.</span> <span class="nav-text">它使用“选取-投影-连接”策略进行查询。例如：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E7%AC%AC-3-%E5%B1%82%EF%BC%9A%E5%BC%95%E6%93%8E%E5%B1%82"><span class="nav-number">1.2.4.</span> <span class="nav-text">1. 5 第 3 层：引擎层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E5%AD%98%E5%82%A8%E5%B1%82"><span class="nav-number">1.2.5.</span> <span class="nav-text">1. 6 存储层</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%83%BD%E6%98%AF%E5%AD%98%E5%9C%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8A%EF%BC%8C%E4%BB%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%98"><span class="nav-number">1.2.5.0.1.</span> <span class="nav-text">所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%B0%8F%E7%BB%93"><span class="nav-number">1.2.6.</span> <span class="nav-text">1. 7 小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E4%B8%BA%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.2.6.0.1.</span> <span class="nav-text">简化为三层结构：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E5%B1%82%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81-SQL-%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%9B"><span class="nav-number">1.2.6.0.2.</span> <span class="nav-text">1. 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-SQL-%E5%B1%82%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%B1%82%EF%BC%89%EF%BC%9A%E5%AF%B9-SQL-%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%EF%BC%9B%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%97%A0%E5%85%B3%EF%BC%9B"><span class="nav-number">1.2.6.0.3.</span> <span class="nav-text">2. SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82%EF%BC%9A%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E6%89%93%E4%BA%A4%E9%81%93%EF%BC%8C%E8%B4%9F%E8%B4%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E8%AF%BB%E5%8F%96%E3%80%82"><span class="nav-number">1.2.6.0.4.</span> <span class="nav-text">3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">2. SQL执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-MySQL-%E4%B8%AD%E7%9A%84-SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">2. 1 MySQL 中的 SQL执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E6%98%AF%E6%8F%90%E5%89%8D%E6%8A%8A%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98%E8%B5%B7%E6%9D%A5%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%B8%8B%E6%AC%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%88%B0%E7%BB%93%E6%9E%9C%E3%80%82%E9%9C%80%E8%A6%81%E8%AF%B4%E6%98%8E%E7%9A%84%E6%98%AF%EF%BC%8C%E5%9C%A8"><span class="nav-number">1.3.1.0.1.</span> <span class="nav-text">查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BC%98%E5%8C%96%E5%99%A8-%EF%BC%9A%E5%9C%A8%E4%BC%98%E5%8C%96%E5%99%A8%E4%B8%AD%E4%BC%9A%E7%A1%AE%E5%AE%9A-SQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%AF%94%E5%A6%82%E6%98%AF%E6%A0%B9%E6%8D%AE%E5%85%A8%E8%A1%A8%E6%A3%80%E7%B4%A2%EF%BC%8C%E8%BF%98%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E6%A3%80%E7%B4%A2%E7%AD%89%E3%80%82"><span class="nav-number">1.3.1.0.2.</span> <span class="nav-text">3. 优化器 ：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引检索等。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E9%98%B6%E6%AE%B5%E5%92%8C%E7%89%A9%E7%90%86%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E9%98%B6%E6%AE%B5%E3%80%82"><span class="nav-number">1.3.1.0.3.</span> <span class="nav-text">在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A7%E8%A1%8C%E5%99%A8-%EF%BC%9A"><span class="nav-number">1.3.1.0.4.</span> <span class="nav-text">4. 执行器 ：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%AA%E6%AD%A2%E5%88%B0%E7%8E%B0%E5%9C%A8%EF%BC%8C%E8%BF%98%E6%B2%A1%E6%9C%89%E7%9C%9F%E6%AD%A3%E5%8E%BB%E8%AF%BB%E5%86%99%E7%9C%9F%E5%AE%9E%E7%9A%84%E8%A1%A8%EF%BC%8C%E4%BB%85%E4%BB%85%E5%8F%AA%E6%98%AF%E4%BA%A7%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E3%80%82%E4%BA%8E%E6%98%AF%E5%B0%B1%E8%BF%9B%E5%85%A5%E4%BA%86%E6%89%A7%E8%A1%8C%E5%99%A8%E9%98%B6%E6%AE%B5%E3%80%82"><span class="nav-number">1.3.1.0.5.</span> <span class="nav-text">截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E5%88%A4%E6%96%AD%E8%AF%A5%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%85%B7%E5%A4%87%E6%9D%83%E9%99%90%E3%80%82%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%E6%9D%83%E9%99%90%E9%94%99%E8%AF%AF%E3%80%82%E5%A6%82%E6%9E%9C%E5%85%B7%E5%A4%87%E6%9D%83%E9%99%90%EF%BC%8C%E5%B0%B1%E6%89%A7%E8%A1%8C-SQL%E6%9F%A5%E8%AF%A2%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%80%82%E5%9C%A8-MySQL8-0-%E4%BB%A5%E4%B8%8B%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BE%E7%BD%AE%E4%BA%86%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BC%9A%E5%B0%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E3%80%82"><span class="nav-number">1.3.1.0.6.</span> <span class="nav-text">在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-MySQL-8-%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 2 MySQL 8 中SQL执行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%A1%AE%E8%AE%A4profiling-%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1. 确认profiling 是否开启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8CSQL%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2. 多次执行相同SQL查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA-SQL-%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA-SQL-%E6%9F%A5%E8%AF%A2%EF%BC%89%EF%BC%9A"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9F%A5%E7%9C%8Bprofiles"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3. 查看profiles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9F%A5%E7%9C%8Bprofile"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">4. 查看profile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.3.2.4.1.</span> <span class="nav-text">显示执行计划，查看程序的执行步骤：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2-SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%9C%E5%92%8C%E4%B8%8A%E9%9D%A2%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82"><span class="nav-number">1.3.2.4.2.</span> <span class="nav-text">查询 SQL 的执行时间结果和上面是一样的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A4%E5%A4%96%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%9F%A5%E8%AF%A2%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">1.3.2.4.3.</span> <span class="nav-text">此外，还可以查询更丰富的内容：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E7%BB%AD%EF%BC%9A"><span class="nav-number">1.3.2.4.4.</span> <span class="nav-text">继续：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-MySQL-5-7-%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">2. 3 MySQL 5. 7 中SQL执行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1. 配置文件中开启查询缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%87%8D%E5%90%AFmysql%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2. 重启mysql服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BC%80%E5%90%AF%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3. 开启查询执行计划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E4%B8%A4%E6%AC%A1%EF%BC%9A"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">4. 执行语句两次：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9F%A5%E7%9C%8Bprofiles"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">5. 查看profiles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%9F%A5%E7%9C%8Bprofile"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">6. 查看profile</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%EF%BC%9A-1"><span class="nav-number">1.3.3.6.1.</span> <span class="nav-text">显示执行计划，查看程序的执行步骤：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%E4%B8%8D%E8%A8%80%E8%80%8C%E5%96%BB%E3%80%82%E6%89%A7%E8%A1%8C%E7%BC%96%E5%8F%B7-2-%E6%97%B6%EF%BC%8C%E6%AF%94%E6%89%A7%E8%A1%8C%E7%BC%96%E5%8F%B7-1-%E6%97%B6%E5%B0%91%E4%BA%86%E5%BE%88%E5%A4%9A%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BB%8E%E6%88%AA%E5%9B%BE%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9B%B4%E6%8E%A5%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD"><span class="nav-number">1.3.3.6.2.</span> <span class="nav-text">结论不言而喻。执行编号 2 时，比执行编号 1 时少了很多信息，从截图中可以看出查询语句直接从缓存中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%82"><span class="nav-number">1.3.3.6.3.</span> <span class="nav-text">获取数据。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-SQL%E8%AF%AD%E6%B3%95%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">2.4 SQL语法顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Oracle%E4%B8%AD%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%BA%86%E8%A7%A3"><span class="nav-number">1.3.5.</span> <span class="nav-text">2.5 Oracle中的SQL执行流程(了解)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%9B%BE%EF%BC%9A"><span class="nav-number">1.3.5.0.1.</span> <span class="nav-text">简图：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">1.3.5.0.2.</span> <span class="nav-text">小结：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0-buffer-pool"><span class="nav-number">1.4.</span> <span class="nav-text">3. 数据库缓冲池(buffer pool)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%BC%93%E5%86%B2%E6%B1%A0-vs-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 缓冲池 vs 查询缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E5%92%8C%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97%EF%BC%9F%E4%B8%8D%E6%98%AF%E3%80%82"><span class="nav-number">1.4.1.0.1.</span> <span class="nav-text">缓冲池和查询缓存是一个东西吗？不是。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BC%93%E5%86%B2%E6%B1%A0%EF%BC%88Buffer-Pool%EF%BC%89"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1. 缓冲池（Buffer Pool）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">2. 查询缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">那么什么是查询缓存呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E6%98%AF%E6%8F%90%E5%89%8D%E6%8A%8A%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%BC%93%E5%AD%98%E8%B5%B7%E6%9D%A5%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%B8%8B%E6%AC%A1%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%88%B0%E7%BB%93%E6%9E%9C%E3%80%82%E9%9C%80%E8%A6%81%E8%AF%B4%E6%98%8E%E7%9A%84%E6%98%AF%EF%BC%8C%E5%9C%A8-1"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">1.4.2.</span> <span class="nav-text">3. 2 缓冲池如何读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E7%AE%A1%E7%90%86%E5%99%A8%E4%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%86%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E8%AF%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%A6%96%E5%85%88%E4%BC%9A%E5%88%A4%E6%96%AD%E8%AF%A5%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E5%9C%A8%E7%BC%93%E5%86%B2%E6%B1%A0%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AD%98%E5%9C%A8%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%B0%B1%E4%BC%9A%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E6%88%96%E7%A3%81%E7%9B%98%E5%B0%86%E9%A1%B5%E9%9D%A2%E5%AD%98%E6%94%BE%E5%88%B0%E7%BC%93%E5%86%B2%E6%B1%A0%E4%B8%AD%E5%86%8D%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%8F%96%E3%80%82"><span class="nav-number">1.4.2.0.1.</span> <span class="nav-text">缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-number">1.4.2.0.2.</span> <span class="nav-text">缓存在数据库中的结构和作用如下图所示：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%89%A7%E8%A1%8C-SQL-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%9B%B4%E6%96%B0%E4%BA%86%E7%BC%93%E5%AD%98%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E4%BC%9A%E9%A9%AC%E4%B8%8A%E5%90%8C%E6%AD%A5%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%8A%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.2.0.3.</span> <span class="nav-text">如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%9F%A5%E7%9C%8B-x2F-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 3 查看&#x2F;设置缓冲池的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%96%E8%80%85%EF%BC%9A"><span class="nav-number">1.4.3.0.1.</span> <span class="nav-text">或者：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%84%B6%E5%90%8E%E5%86%8D%E6%9D%A5%E7%9C%8B%E4%B8%8B%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E7%BC%93%E5%86%B2%E6%B1%A0%E5%A4%A7%E5%B0%8F%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%B7%B2%E6%88%90%E5%8A%9F%E4%BF%AE%E6%94%B9%E6%88%90%E4%BA%86-256-MB%EF%BC%9A"><span class="nav-number">1.4.3.0.2.</span> <span class="nav-text">然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%A4%9A%E4%B8%AABuffer-Pool%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.4.4.</span> <span class="nav-text">3.4 多个Buffer Pool实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%BC%95%E7%94%B3%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.5.</span> <span class="nav-text">3.5 引申问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%91%E6%9B%B4%E6%96%B0%E5%88%B0%E4%B8%80%E5%8D%8A%E7%AA%81%E7%84%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E4%BA%86%EF%BC%8C%E6%83%B3%E8%A6%81%E5%9B%9E%E6%BB%9A%E5%88%B0%E6%9B%B4%E6%96%B0%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E8%BF%9E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%BF%9D%E8%AF%81%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9B%9E"><span class="nav-number">1.4.5.0.1.</span> <span class="nav-text">我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BB%9A%E9%83%BD%E5%81%9A%E4%B8%8D%E5%88%B0%E8%BF%98%E8%B0%88%E4%BB%80%E4%B9%88%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="nav-number">1.4.5.0.2.</span> <span class="nav-text">滚都做不到还谈什么崩溃恢复？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wenchao"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">wenchao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangwenchao1991" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangwenchao1991" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/349205260" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;349205260" rel="noopener" target="_blank"><i class="iconfont icon-bilibili fa-fw"></i>Bilibili</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wenchao</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
